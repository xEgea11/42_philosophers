NO LIBFT

printf (original), malloc, free, write, 

<string.h>
void *memset(void *b, int c, size_t len)
    copies c to *b 
    returns *b

unsleep (implement by ourselves)

<sys/time.h>
int gettimeofday (struct timeval *restrict tp, void *restrict tzp) <-- just put 1 of the 2 args;tzp is obsolete, should be specified as NULL

            struct timeval
                time_t          tv_sec  <----seconds
                susseconds_t    tv_usec <----microseconds  //USAREMOS ESTE COMPONENTE
    example: 

                struct timeval milis;
                
                gettimeofday(milis.tv_usec, NULL) // ejecutamos sobre el componente de milisegundos y dejamos el componente tz en NULL (no nos interesa)
                printf("%i", milis.tv_usec) // la variable tiene guardada la informacion despues de ejecutar la funcion gettimeofday; se puede imprimir 
                
<pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,   // Returns 0 if successfull
                   void *(*start_routine)(void *), void *arg)



int phtread_detach (pthread thread)             //Marks the thread as detached; it releases its resources automatically when it terminates; returns 0 if successfull


//Waits for the thread specified (first argument) to terminate. If that thread has already terminated, the funcion returns immediately. 
//The "thread" must be joinable
//"Retval" can be NULL; if not, the function copies the exit status of the thread to "retval" 
int pthread_join(pthread_t thread, void **retval) 

//attr can be NULL, if so; default are used; mutex become initialized and UNLOCKED; it shall return 0 if successfull
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)

// The mutex object becomes uninitialized; the mutex must be UNLOCKED in order to destroy it; Attempting to destroy a locekd mutex is an undefined behavior
// It shall return 0 if successfull
int pthread_mutex_destroy(pthread_mutex_t *mutex)


/*CHECK WHAT IT MEANS TO USE PTHREAD_MUTEX_DEFAULT OR _RECURSIVE OR _ERROR_CHECK OR _NORMAL
//Locks the mutex; if its already locked, the thread blocks until its available
//Checks if mutex is available; it waits if its not; when it releases it set the lock to 
available
//This function shall return with the mutex object in locked state with the calling thread
//as its owner
int pthread_mutex_lock (pthread_mutex_t *mutex)

//It releases the mutex object 
int pthread_mutex_unlock (pthread_mutex_t *mutex)

//Not allowed, but search info
terminates the calling thread and returns a value via retval 
void pthread_exit (void *retval)
